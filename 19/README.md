Практика:

1) Прикрутить к форуму ЧПУ двумя способами
- через функцию генерации адресов
- через буферизацию вывода

2) Сделать дамп/ экспорт вашей базы форума и построчно разобрать каждую команду и ее синтаксис ( каждую команду - что делает, какие опции имеет и тп)


Теория
1) Посмотреть вопросы в прилагаемом файле

2)
http://vk-book.ru/primer-mvc-v-php-vvodnaya-statya/  ( все три статьи )
http://habrahabr.ru/post/150267/
http://mail.erdeluxe.ru/mvc

Если будет время - посмотрите исходник  https://github.com/vvs-code/Simple-MVC ( мы его будем разбирать позже - сейчас просто можете поставить его себе локально и попробовать запустить / пройтись по коду )
1. Что такое реляционная база данных?
Реляционная база данных – это база данных, основанная на реляционной модели данных. Ре-ляционная модель ориентирована на организацию данных в виде двумерных таблиц. Каждая
реляционная таблица представляет собой двумерный массив и обладает следующими свойс-твами:
– каждый элемент таблицы – один элемент данных;
– все ячейки в столбце таблицы однородные, то есть все элементы в столбце имеют одинаковый
тип (числовой, символьный и т. д.);
– каждый столбец имеет уникальное имя;
– одинаковые строки в таблице отсутствуют;
– порядок следования строк и столбцов может быть произвольным.


2. Что такое первичный ключ?
Первичный ключ (primary key) – столбец, значения которого во всех строках различны. Пер-вичные ключи могут быть логическими (естественными) и суррогатными (искусственными).
Так, для воображаемой таблицы “Users” первичным ключом может стать столбец e-mail (ведь
теоретически не может быть двух пользователей с одинаковым e-mail). Но на практике лучше
использовать суррогатные ключи, т.к. их применение позволяет абстрагировать ключи от ре-альных данных. Кроме того, первичные ключи менять нельзя, но что если у пользователя сме-нится e-mail?
Суррогатный ключ представляет собой дополнительное поле в базе данных. Как правило, это
порядковый номер записи (хотя вы можете задавать их на свое усмотрение, контролируя, чтобы
они были уникальны).


3. Что такое нормализация и денормализация?
Нормализация – это процесс приведения базы данных к виду, в котором она будет соответство-вать правилам нормальных форм. Нормализация сводит к минимуму количество избыточной
информации. Ее целью является сохранять данные только один раз, но в нужном месте.
Нормализованная база данных исключает дублирование и многократное обслуживание дан-ных, а также появление проблем с целостностью данных, возникающих при повторном вводе
одинаковых данных.
Денормализация – это процесс осознанного приведения базы данных к виду, в котором она не
будет соответствовать правилам нормализации. Обычно это необходимо для повышения про-изводительности и скорости извлечения данных за счет увеличения избыточности данных.
Если приложению необходимо часто выполнять выборки, которые занимают слишком много
времени (например, объединение данных из множества таблиц), то следует рассмотреть возможность проведения денормализации.
Возможное решение следующее: вынести результаты выборки в отдельную таблицу. Это позво-лит увеличить скорость выполнения запросов, но также означает появление необходимости в
постоянном обслуживании этой новой таблицы.
Прежде чем приступать к денормализации, необходимо убедится, что ожидаемые результаты
оправдывают издержки, с которыми придется столкнуться.


4. Что такое mysql_pconnect? Чем он отличается от mysql_connect?
При использовании функции mysql_connect() каждый раз открывается новое соединение с ба-зой данных. После вызова mysql_close() или после завершения работы скрипта соединение за-крывается.
Отличия mysql_pconnect() заключаются в том, что, во-первых, при вызове функции сначала
ищется уже открытое (постоянное) соединение с базой (persistent connection), если его нет – со-здается новое. Во-вторых, после завершения работы скрипта и при вызове mysql_close() соеди-нение с базой MySQL не закрывается, а остается открытым для последующего использования.


5. Что такое MyISAM и InnoDB?
MyISAM и InnoDB – это типы таблиц.


6. Чем они отличаются?
MyISAM
– не поддерживает транзакции и с этим связаны его основные недостатки и преимущества;
– в большинстве случаев он быстрее, так как нет расходов на транзакции;
– занимает меньше дискового пространства;
– меньше расход памяти на обновления;
– полнотекстовый индекс;
– быстрый INSERT, SELECT.
InnoDB
– поддержка транзакций;
– построчная блокировка. UPDATE не блокирует всю таблицу;
– отлично ведет себя при смешанной нагрузке (insert|select|update|delete).


7. Что такое SQL-инъекция?
SQL-инъекции – встраивание вредоносного кода в запросы к базе данных. С использованием
SQL-инъекций злоумышленник может не только получить закрытую информацию из базы дан-ных, но и, при определенных условиях, внести туда изменения.
Уязвимость по отношению к SQL-инъекциям возникает из-за того, что пользовательская инфор-мация попадает в запрос к базе данных без должной обработки: чтобы скрипт не был уязвим,
требуется убедиться, что все пользовательские данные попадают во все запросы к базе данных
в экранированном виде.


8. Есть две таблицы:
users - таблица с пользователями (users_id, name)
orders - таблица с заказами (orders_id, users_id, status)
1) Выбрать всех пользователей из таблицы users, у которых ВСЕ записи в таб-лице orders имеют status = 0
2) Выбрать всех пользователей из таблицы users, у которых больше 5 запи-сей в таблице orders имеют status = 1
1) Выбор пользователей с использованием вложенного запроса:
SELECT * FROM users WHERE users_id NOT IN (
SELECT users_id FROM orders WHERE status <> 0)
2) C использованием JOIN и HAVING:
SELECT u.* FROM orders o
JOIN users u ON u.users_id = o.users_id
WHERE o.status = 1 GROUP BY o.users_id
HAVING COUNT(o.status) > 5


9. Какая разница между LEFT, RIGHT и INNER JOIN?
Основное различие в том, как соединяются таблицы, если нет общих записей.
Простой JOIN – это то же самое, что INNER JOIN, он показывает только общие записи обоих таб-лиц. Каким образом записи считаются общими, определяется полями в join-выражении. Напри-мер, следующая запись:
FROM t1 JOIN t2 on t1.id = t2.id
означает что будут показаны записи с одинаковыми id, существующие в обоих таблицах.
LEFT JOIN(или LEFT OUTER JOIN) означает показывать все записи из левой таблицы (той, кото-рая идет первой в join-выражении) независимо от наличия соответствующих записей в правой таблице.
RIGHT JOIN(или RIGHT OUTER JOIN) действует в противоположность LEFT JOIN - показывает все
записи из правой (второй) таблицы и только совпавшие из левой (первой) таблицы.
LEFT JOIN:
– при выполнении условия сцепления таблиц, к ячейкам из первой таблицы присоединяются
ячейки второй;
– если условие не выполняется, присоединяются пустые ячейки.
INNER JOIN:
– при выполнении условия тоже, что и с LEFT JOIN;
– если условие не выполняется, строка вообще игнорируется (не будет ячеек даже из первой
таблицы).
Проще говоря, LEFT JOIN выберет из первой таблицы все записи, даже если во второй таблице
нет совпадений по какому-то условию. INNER JOIN выберет только те, что полностью соответс-твуют условию.


10. Чем отличается WHERE от HAVING?
При помощи HAVING отражаются все предварительно сгруппированные посредством GROUP BY
блоки данных, удовлетворяющие заданным в HAVING условиям. Это дополнительная возмож-ность “профильтровать” выходной набор.
Условия в HAVING отличаются от условий в WHERE:
– В условии поиска WHERE нельзя задавать агрегатные функции;
– HAVING исключает из результирующего набора данных группы с результатами агрегирован-ных значений;
– WHERE исключает из расчета агрегатных значений по группировке записи, не удовлетворяю-щие условию.


11. Что можешь сказать про команду GROUP BY?
GROUP BY используется для группировки результата одного или нескольких столбцов.
Синтаксис:
SELECT column_name, aggregate_function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name


12. Приведи пример использования GROUP BY.
Есть следующая таблица “Orders”:
Id Date Price Customer
1 2012/02/12 1000 Vasya
2 2012/03/17 1600 Petro
3 2012/01/25 700 Vasya
4 2012/01/03 300 Vasya
5 2012/02/21 2000 Ivan
6 2012/02/18 100 Petro
Теперь мы хотим найти общую сумму заказа для каждого клиента. Выполним запрос:
SELECT Customer,SUM(Price) FROM Orders GROUP BY Customer
Результат запроса:
Customer SUM(Price)
Vasya 2000
Petro 1700
Ivan 2000
Теперь давайте посмотрим, что произойдет, если мы не используем запрос GROUP BY:
SELECT Customer,SUM(Price) FROM Orders
Результат запроса:
Customer SUM(Price)
Vasya 5700
Petro 5700
Vasya 5700
Vasya 5700
Ivan 5700
Petro 5700


13. Допустим, у тебя есть Интернет-магазин. Составь запрос, который покажет
сколько денег принес каждый отдельно взятый покупатель в общей сложнос-ти за всё время существования магазина.
SELECT customer_name, SUM(order_price) FROM orders
GROUP BY customer_name;


14. А теперь пусть этот же запрос показывает только тех, кто купил товаров в
общей сложности минимум на 10 тысяч евро.
SELECT customer_name, SUM(order_price) FROM orders
GROUP BY customer_name HAVING SUM(order_price) >= 10000;


15. Что делает команда EXPLAIN?
EXPLAIN может в точности рассказать, что происходит, когда мы выполняем запрос. Эта инфор-мация позволит нам обнаружить медленные запросы и сократить время, затрачиваемое на об-работку запроса, что впоследствии может значительно ускорить работу вашего приложения.
Вот пример использования этой команды:
EXPLAIN SELECT * FROM users WHERE id=’42’
Если оператор SELECT предваряется ключевым словом EXPLAIN, MySQL сообщит о том, как бу-дет производиться обработка SELECT, и предоставит информацию о порядке и методе связыва-ния таблиц.
При помощи EXPLAIN можно выяснить, когда стоит снабдить таблицы индексами, чтобы полу-чить более быструю выборку, использующую индексы для поиска записей. Кроме того, мож-но проверить, насколько удачный порядок связывания таблиц был выбран оптимизатором.
Заставить оптимизатор связывать таблицы в заданном порядке можно при помощи указания
STRAIGHT_JOIN.
Для непростых соединений EXPLAIN возвращает строку информации о каждой из использован-ных в работе оператора SELECT таблиц. Таблицы перечисляются в том порядке, в котором они
будут считываться. MySQL выполняет все связывания за один проход (метод называется “singlesweep multi-join”). Делается это так: MySQL читает строку из первой таблицы, находит совпа-дающую строку во второй таблице, затем - в третьей, и так далее. Когда обработка всех таблиц
завершается, MySQL выдает выбранные столбцы и обходит в обратном порядке список таблиц
до тех пор, пока не будет найдена таблица с наибольшим совпадением строк. Следующая строка
считывается из этой таблицы и процесс продолжается в следующей таблице.


16. Как вывести все поля из таблицы my_table?
SELECT * FROM my_table


17. Как вывести только поля name_first, name_last, salary из
таблицы my_table?
SELECT name_first, name_last, salary FROM my_table


18. Таблице my_table задать псевдоним t и вывести всех, у кого salary
выше 3800
SELECT * FROM my_table AS t WHERE t.salary>3800


19. Выбрать страны, из которых поставляют продукцию производители, так,
чтобы страны не повторялись по 2 и более раз.
SELECT DISTINCT country FROM manufacturers


20. Вывести всех украинских производителей.
SELECT * FROM manufacturers WHERE country=”Ukraine”


21. Вывести только тех производителей, которые находятся во Львове
и Харькове.
SELECT * FROM manufacturers WHERE area=”Львов” OR area=”Харьков”


22. Вывести все модели автобусов ЛАЗ, вместимостью не менее 15 пассажи-ров.
SELECT * FROM buses WHERE brand=”ЛАЗ” AND NOT seats<15


23. Вывести все автобусы в порядке возрастания количества мест.
SELECT * FROM buses ORDER BY seats


24. Вывести все автобусы в порядке уменьшения количества мест.
SELECT * FROM buses ORDER BY seats DESC


25. Какие знаешь команды для подсчета значений поля?
SELECT MAX(seats) FROM buses// Выведет автобус с максимальным количеством сидений
SELECT MIN(seats) FROM buses// Выведет автобус с минимальным количеством сидений
SELECT SUM(seats) FROM buses// Выведет общее количество сидений во всех автобусах
SELECT AVG(seats) FROM buses// Выведет среднее количество сидений
SELECT COUNT(*) FROM buses// Выведет общее количество автобусов в таблице
SELECT COUNT(*) FROM buses WHERE brand=”ЛАЗ”// Выведет количество автобусов ЛАЗ


26. Предположим, у нас есть таблица в которой есть поля name и id. Нужно
вывести имя с наибольшим id, не используя при этом команду MAX. Как это
можно сделать?
Отсортировать по id в сторону уменьшения, но вывести только первый id. Он и будет наиболь-шим:
SELECT name, id FROM customers ORDER BY id DESC LIMIT 1


27. С помощью конструкции IN вывести производителей из Украины, Герма-нии и США.
SELECT * FROM manufacturer WHERE country IN
(“Украина”, “Германия”, “США”)


28. Вывести всех производителей за исключением тех, которые находятся в
Китае, Таджикистане и России.
SELECT * FROM manufacturer WHERE country NOT IN
(“Китай”,”Таджикистан”, “Россия”)


29. Вывести пустые / не пустые значения.
пустые:
SELECT * FROM manufacturer WHERE location IS NULL
не пустые:
SELECT * FROM manufacturer WHERE location IS NOT NULL


30. Вывести только те автобусы, названия которых начинаются на букву M.
SELECT * FROM buses WHERE brand LIKE “М%”


31. Мы не помним как точно пишется “Mercedes“ или “Mersedes“, но нужно из
таблицы выбрать автобусы именно этой марки. Как быть?
Воспользоваться знаком подчеркивания, который означает “любой символ”:
SELECT * FROM buses WHERE brand LIKE “Mer_edes”


32. Выбрать только те автобусы, цена которых лежит в пределах от 100000
до 180000 долларов включительно.
SELECT * FROM buses WHERE price BETWEEN 100000 AND 180000


33. Подсчитать количество автобусов в таблице, у которых 45 мест.
SELECT COUNT(brand) FROM buses WHERE seats=45


34. Приведи пример вложенного запроса.
SELECT * FROM buses WHERE price=(SELECT MAX(price) FROM buses)


35. Можно ли выбрать данные из нескольких таблиц?
Да, например вот так:
SELECT o.order_no, o.amount_paid, с.company
FROM orders AS o
LEFT JOIN customer AS с ON (с.custno=o.custno)


36. Обязательно ли писать команды прописными буквами? Сработает ли за-прос, если его написать строчными буквами?
Работать будет, т.к. команды MySQL регистронезависимы. Но, тем не менее, команды традици-онно принято писать прописными буквами для удобства чтения запроса.


37. А будет ли работать такой запрос: SELECT city FROM
customers?
Будет. MySQL не обращает внимания на пробелы и разрывы строки между командами.


38. Что выберет такой запрос: SELECT brand FROM buses WHERE brand REGEXP
‘lvo|ool‘?
Выберет все автобусы, в названиях которых встречается “lvo“ или “ool“. Например, Volvo и Van
Hool.


39. У нас есть таблица usa, в которой есть колонка city с названиями городов
и колонка state, с названиями штатов. Нужно вывести новую колонку new_
column, которая будет содержать название города и через запятую название
штата, в котором находится этот город. Например вот так: Raleigh, NC.
SELECT CONCAT(city, ‘,‘, state) AS new_column FROM usa


40. Есть таблица one, к ней нужно добавить таблицу two, которая содержит
такие же поля (id, name, seller, price). Как это сделать?
INSERT INTO one(id, name, seller, price) SELECT id, name, seller,
price FROM two
